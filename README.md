# RPC搭建过程梳理

![框架图](https://raw.githubusercontent.com/HaydnSyx/syx-rpc/main/img/SYX_RPC_ARCHITECTURE.png)

## 框架核心
### 服务端

1. 暴露对外接口
2. 反序列化请求数据
3. 找到对应的方实现并执行
4. 序列化后返回结果

### 客户单

1. 对所有rpc接口进行代理
    1. 获取远程实现服务实例
    2. 序列化请求信息
    3. 使用网络通信客户端按照协议传输数据
2. 反序列化数据获取结果

## 框架进阶

### 服务端

1. 将服务注册到注册中心，由注册中心对外提供信息
2. 维持与注册中心的心跳连接
### 客户端

1. 访问注册中心，从注册中心获取服务信息，并订阅服务的状态
2. 动态代理实现方式
    1. JDK动态代理
    2. CGLib动态代理
    3. ByteBuddy动态代理
    4. Javassist动态代理
3. 多种负载均衡机制
4. 增加重试/超时机制
5. 增加过滤器机制
6. 增加故障处理机制
7. 增加动态调整请求信息机制

## 框架实现细节

### 序列化/反序列化

一般通信息协议使用json，json解析的框架由Jackson、gson、fastjson等，但是json的序列化反序列化性能较差，再高并发场景下不占优势

其他序列化框架：
* Protocol Buffers
* Kryo
* FST
* Avro
* MessagePack
* Hessian
* Jackson
* Gson
* Fastjson
* Bson

### 通信交互

一般协议之间的通信走http/http2协议，http交互框架性能比较好的有OkHttp。

其他协议一般使用框架自定义实现，比如netty

### 负载均衡

* 轮询算法
* 权重设定
* 动态调整权重


### 客户端组件

传输器 -> 可自定义实现（单一实现），默认实现okHttp
编解码器 -> 可定义实现（单一实现），默认实现为fastjson
过滤器 -> 可自定义实现（多种实现），默认为上下文传递过滤器
路由器 -> 可自定义实现（单一实现），默认为空实现
负载均衡器 -> 可自定义实现（单一实现，提供多种默认策略），默认为轮询实现
动态代理 -> 可自定义实现（单一实现），默认为JDKProxy

#### 客户端启动器封装

##### 环境上下文
1. 命名空间
2. 环境
3. 组

环境上下文 + 接口全限定名 + 接口版本 === > 代表唯一接口（ServiceMeta）
通过ServiceMeta 从注册中心/配置中心获取该接口的所有服务实例
##### 启动上下文（RpcContext）
1. 传输器
2. 编解码器
3. 过滤器
4. 路由器
5. 负载均衡器

###### 接口对应的消费者配置上下文（RpcConsumerContext）

1. [接口维度]访问超时时间
2. [接口维度]重试次数
3. [接口维度]连接超时时间
4. [接口维度]故障隔离相关配置
5. [接口维度]过滤器链表
6. [方法维度]访问超时时间
7. [方法维度]重试次数
8. [方法维度]过滤器链表

优先级：方法级别 > 接口级别 > 系统级别（有默认值）


#### 消费者执行器（动态代理）

通过上述的`启动上下文`，`配置上下文`，`服务实例列表`来组件`执行器`



### 服务端组件

传输器 -> 可自定义实现（单一实现），默认实现SpringBoot
编解码器 -> 可定义实现（多种实现），默认实现为fastjson
过滤器 -> 暂不支持
